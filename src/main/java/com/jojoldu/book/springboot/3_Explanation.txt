JPA 소개
현대의 웹 애플리케이션에서 관계형 데이터베이스 RDB는 빠질 수 없는 요소이다.그러다 보니 객체를 관계형 데이터베이스에서 관리하는 것이
무엇보다 중요하다.
관계형 데이터베이스가 계속해서 웹 서비스의 중심이 되면서 모든 코드는 SQL 중심이 되어간다.
이는 관계형 데이터베이스가 SQl만 인식할 수 있기 때문엔데, SQl로만 가능하니 각 테이블마다 기본적인 CRUD SQL을 매번 생성해야 한다.
개발자가 아무리 자바 클래스를 아름답게 설계해도, SQL을 통해야만 데이터베이스에 저장하고 조회할 수 있다.
결국, 관계형 데이터베이스를 사용해야만 하는 상황에서 SQL은 피할 수 없다.

또한, 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다르므로 객체를 데이터베이스에
저장하려고 하면 여러 문제가 발생한다. 이를 패러다임 불일치라고 한다.

위와 같은 여러 문제를 해결하기 위해 JPA가 등장한다.
서로 지향하는 바가 다른 2개영역을 중간에서 패러다임 일치를 시켜주기 위한 기술이라고 할 수 있다.

즉, 개발자는 객체지향적으로 프로그래밍을 하고 JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행한다.
개발자는 더는 SQL에 종속적인 개발을 하지 않아도 된다.


Spring Data JPA
JPA는 인터페이스로서 자바 표준명세서이다. 인터페이스인 JPA를 사용하기 위해서는 구현체가 필요하다.
대표적으로 Hibernate, Eclipse, Link 등이 있지만 Spring에서 JPA를 사용할 때는 이 구현체들을 직접 다루진 않는다.
구현체들을 좀 더 쉽게 사용하고자 추상화시킨 Spring Data JPA라는 모듈을 이용하여 JPA 기술을 다룬다.
> JPA <- Hibernate <- Spring Data JPA
이렇게 한 단계 더 감싸놓은 Spring Data JPA가 등장한 이유는 크게 두가지가 있다
- 구현체 교체의 용이성
- 저장소 교체의 용이성
구현체 교체의 용이성은 Hibernate외에 다른 구현체로 쉽게 교체하기 위함이다.
저장소 교체의 용이성이란 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함이다.
( 예로, MongoDB로 교체가 필요하다면 개발자는 Spring Data JPA에서 Spring Data MongoDB로 의존성만 교체하면 된다. )

------------------
domain 패키지 -> 도메인을 담을 패키지
여기서 도메인이란 게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제 영역이다.

도메인 페키지의 posts 페키지의  post 클래스는 실제 DB의 테이블과 매칭될 클래스이며 보통 Entity 클래스라고도 한다.
JPA를 사용하면 DB 데이터에 작업할 경우 실제 쿼리를 날리기보다, 이 entity 클래스의 수정을 통해 작업한다.


API를 만들기 위해 총 3개의 클래스가 필요
Request 데이터를 받을 Dto
API 요청을 받을 Controller
트랜잭션, 도메인 기능 간의 순서를 보장하는 Service

Service는 비지니스 로직을 처리하지 않음 비지니스 로직은 Domain에서 처리한다.

Spring 웹 계층
==========================================
|Web Layer           |                   |
|                    |    DTO            |
|Service Layer       |                   |
|                    |    Domain Modelr  |
|Repository Layer    |                   |
==========================================
Web Layer
흔히 사용하는 컨트롤러와 JSP/Freemarker 등의 뷰 템플릿 영역
이외에도 필터, 인터셉터, 컨트롤러 어드바이스 등 외부 요청과 응답에 대한 전반적인 영역을 이야기한다.

Service Layer
@Service에 사용되는 서비스 영역
일반적으로 Controller와 Dao의 중간 영역에서 사용된다.
@Transactional이 사용되는 부분
서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장해 준다

Repository Layer
Database와 같이 데이터 저장소에 접근하는 영역
Dao 영역

Dtos
Dto(Data Transfer Object)는 계층 간에 데이터 교환을 위한 객체를 이야기하며 Dtos는 이들의 영역을 예기
예를 들어 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준 객체 등이 이들을 이야기

Domain Model
도메인이라 불리는 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨것을 도메인 모델이라고 함
ex) 택시 앱 - 배차, 탑승, 요금 등이 모두 도메인이 될 수 있다.
@Entity가 사용된 영역 역시 도메인 모델
다만, 무조건 데이터베이스의 테이블과 관계가 있어야만 하는것은 아니다.
VO 처럼 값 객체들도 이영역에 해당하기 때문

------------------------------------------------------------------------------------------------------------

*스프링 빈
Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라고 부름
(제어의 역전 IoC >  Spring에 의하여 관리당하는 자바 객체를 사용합니다. 이렇게 Spring에 의하여 생성되고 관리되는 자바 객체를 Bean이라고 함)

스프링에서 Bean을 주입받는 방식
@Autowured,  setter,  생성자
이 중 가장 권장하는 방식이 생성자 방식이다.(@AutoWired 는 권장하지 않는다.)
Service와 Controller에서 @RequiredArgsConstructor가 이를 해결해준다.
final이 선언된 모든 필드를 인자값으로 하는 생성자를 롬복의 @RequiredArgsConstructor가 대신 생성해준다.
생성자를 직접 안 쓰고 롬복 어노테이션을 사용하는 이유는
해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속해서 수정하는 번거로움을 해결하기 위함이다.

------------------------------------------------------------------------------------------------------------

dto클래스는 Entity클래스와 거의 유사한 형태이다.
절대로 Entity 클래스를 Request/Response 클래스로 사용해서는 안된다.
Entity 클래스는 데이터베이스와 맞닿은 핵심 클래스이다. Entity 클래스를 기준으로 테이블이 생성되고, 스키마가 변경된다.
Entity 클래스가 변경되면 여러 클래스에 영향을 끼치지만, Request와 Respose용 Dto는 View를 위한 클래스라 정말 자주 변경이 필요하다.

View Layer와 DB Layer의 역할 분리를 철저하게 하는게 좋다.
실제로 Controller에서 결과값으로 여러 테이블을 조인해서 줘야 할 경우가 빈번하므로 Entity 클래스만으로 표현하기가 어려운 경우가 많다.

*Entity Class란
domain package
실제 DB의 테이블과 매칭될 클래스
즉, 테이블과 링크될 클래스임을 나타낸다.
Entity 클래스 또는 가장 Core한 클래스라고 부른다.
@Entity, @Column, @Id 등을 이용
최대한 외부에서 Entity 클래스의 getter method를 사용하지 않도록 해당 클래스 안에서 필요한 로직 method을 구현한다.
단, Domain Logic만 가지고 있어야 하고 Presentation Logic을 가지고 있어서는 안된다.
여기서 구현한 method는 주로 Service Layer에서 사용한다.

------------------------------------------------------------------------------------------------------------

JPA Auditing 으로 생성시간/수정시간 자동화하기
보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함한다.
언제 만들어졌는지, 언제 수정되었는지 등은 차후 유지보수에 있어 굉장히 중요한 정보이기 때문이다.
그렇다 보니 매번 DB에 삽입하기전 갱신하기전에 날짜 데이터를 등록/수정하는 코드가 여기저기 들어가게 된다.
이런 단순하고 반복적인 코드가 모든 테이블과 서비스 메소드에 포함되어야 한다면 귀찮고 코드가 지저분해질 수 있다.
이런 문제를 해결하고자 JAP Auditing을 사용한다.
