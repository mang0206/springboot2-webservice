/*
API를 만들기 위해 총 3개의 클래스가 필요
Request 데이터를 받을 Dto
API 요청을 받을 Controller
트랜잭션, 도메인 기능 간의 순서를 보장하는 Service

Service는 비지니스 로직을 처리하지 않음 비지니스 로직은 Domain에서 처리한다.

Spring 웹 계층
==========================================
|Web Layer           |                   |
|                    |    DTO            |
|Service Layer       |                   |
|                    |    Domain Modelr  |
|Repository Layer    |                   |
==========================================
Web Layer
흔히 사용하는 컨트롤러와 JSP/Freemarker 등의 뷰 템플릿 영역
이외에도 필터, 인터셉터, 컨트롤러 어드바이스 등 외부 요청과 응답에 대한 전반적인 영역을 이야기한다.

Service Layer
@Service에 사용되는 서비스 영역
일반적으로 Controller와 Dao의 중간 영역에서 사용된다.
@Transactional이 사용되는 부분

Repository Layer
Database와 같이 데이터 저장소에 접근하는 영역

Dtos
Dto(Data Transfer Object)는 계층 간에 데이터 교환을 위한 객체를 이야기하며 Dtos는 이들의 영역을 예기
예를 들어 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준 객체 등이 이들을 이야기

Domain Model
도메인이라 불리는 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨것을 도메인 모델이라고 함
ex) 택시 앱 - 배차, 탑승, 요금 등이 모두 도메인이 될 수 있다.
@Entity가 사용된 영역 역시 도메인 모델
다만, 무조건 데이터베이스의 테이블과 관계가 있어야만 하는것은 아니다.
VO 처럼 값 객체들도 이영역에 해당하기 때문

------------------------------------------------------------------------------------------------------------

*스프링 빈
Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라고 부름
(제어의 역전 IoC >  Spring에 의하여 관리당하는 자바 객체를 사용합니다. 이렇게 Spring에 의하여 생성되고 관리되는 자바 객체를 Bean이라고 함)

스프링에서 Bean을 주입받는 방식
@Autowured,  setter,  생성자
이 중 가장 권장하는 방식이 생성자 방식이다.(@AutoWired 는 권장하지 않는다.)
Service와 Controller에서 @RequiredArgsConstructor가 이를 해결해준다.
final이 선언된 모든 필드를 인자값으로 하는 생성자를 롬복의 @RequiredArgsConstructor가 대신 생성해준다.
생성자를 직접 안 쓰고 롬복 어노테이션을 사용하는 이유는
해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속해서 수정하는 번거로움을 해결하기 위함이다.

------------------------------------------------------------------------------------------------------------

dto클래스는 Entity클래스와 거의 유사한 형태이다.
절대로 Entity 클래스를 Request/Response 클래스로 사용해서는 안된다.
Entity 클래스는 데이터베이스와 맞닿은 핵심 클래스이다. Entity 클래스를 기준으로 테이블이 생성되고, 스키마가 변경된다.
Entity 클래스가 변경되면 여러 클래스에 영향을 끼치지만, Request와 Respose용 Dto는 View를 위한 클래스라 정말 자주 변경이 필요하다.

View Layer와 DB Layer의 역할 분리를 철저하게 하는게 좋다.
실제로 Controller에서 결과값으로 여러 테이블을 조인해서 줘야 할 경우가 빈번하므로 Entity 클래스만으로 표현하기가 어려운 경우가 많다.

*Entity Class란
domain package
실제 DB의 테이블과 매칭될 클래스
즉, 테이블과 링크될 클래스임을 나타낸다.
Entity 클래스 또는 가장 Core한 클래스라고 부른다.
@Entity, @Column, @Id 등을 이용
최대한 외부에서 Entity 클래스의 getter method를 사용하지 않도록 해당 클래스 안에서 필요한 로직 method을 구현한다.
단, Domain Logic만 가지고 있어야 하고 Presentation Logic을 가지고 있어서는 안된다.
여기서 구현한 method는 주로 Service Layer에서 사용한다.

------------------------------------------------------------------------------------------------------------

JPA Auditing 으로 생성시간/수정시간 자동화하기
보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함한다.
언제 만들어졌는지, 언제 수정되었는지 등은 차후 유지보수에 있어 굉장히 중요한 정보이기 때문이다.
그렇다 보니 매번 DB에 삽입하기전 갱신하기전에 날짜 데이터를 등록/수정하는 코드가 여기저기 들어가게 된다.
이런 단순하고 반복적인 코드가 모든 테이블과 서비스 메소드에 포함되어야 한다면 귀찮고 코드가 지저분해질 수 있다.
이런 문제를 해결하고자 JAP Auditing을 사용한다.
 */